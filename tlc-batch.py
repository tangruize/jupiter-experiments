#!/usr/bin/python3
# -*- coding: UTF-8 -*-

# Created by tangruize on 19-1-18.
import sys
import re
import os
import datetime

from configparser import ConfigParser


class TLCConfigFile:
    """generate TLC config file"""
    model_sym_pat = re.compile(r'\[model value\]<symmetrical>{(.*)}')
    model_pat = re.compile(r'\[model value\]{(.*)}')
    tag = '\\* Generated by tlc-batch.py'

    def __init__(self, cfg, output_cfg_fn=None, output_tla_fn=None):
        self.cfg = cfg
        self.output_cfg_fn = output_cfg_fn if output_cfg_fn is not None else 'MC.cfg'
        self.output_tla_fn = output_tla_fn if output_tla_fn is not None else 'MC.tla'
        self.module_name = os.path.basename(cfg.get('options', 'target')).rstrip('.tla')
        self.output_cfg = []
        self.output_tla = []
        self.parse()

    def _add_behavior(self, specifier, prefix, value):
        behavior_name = '{}_{}'.format(prefix, id(value))
        behavior_value = '{} ==\n{}'.format(behavior_name, value)
        self.output_cfg.append('{}\n{}'.format(specifier, behavior_name))
        self.output_tla.append(behavior_value)

    def _parse_behavior(self):
        """parse behavior section"""
        if 'behavior' in self.cfg:
            behavior = self.cfg['behavior']
            init_predicate = behavior.get('init')
            next_state = behavior.get('next')
            temporal_formula = behavior.get('temporal formula')
            if (init_predicate or next_state) and (not init_predicate or not next_state or temporal_formula):
                raise ValueError('[behavior] choose one or none: "init/next" **OR** "temporal formula"')
            if temporal_formula:
                self._add_behavior('SPECIFICATION', 'spec', temporal_formula)
            else:
                self._add_behavior('INIT', 'init', init_predicate)
                self._add_behavior('NEXT', 'next', next_state)

    def _add_specifications(self, keyword, specifier, prefix):
        """invariants and properties share the same parser"""
        if keyword in self.cfg:
            spec = self.cfg[keyword]
            spec_names = '\n'.join('{}_{}_{}'.format(prefix, i, id(i)) for i in spec)
            if spec_names != '':
                self.output_cfg.append('{}\n{}'.format(specifier, spec_names))
                spec_values = '\n'.join('{}_{}_{} ==\n{}'.format(prefix, i, id(i), spec[i]) for i in spec)
                self.output_tla.append(spec_values)

    def _parse_invariants(self):
        """parse invariants section"""
        self._add_specifications('invariants', 'INVARIANT', 'inv')

    def _parse_properties(self):
        """parse properties section"""
        self._add_specifications('properties', 'PROPERTY', 'prop')

    def _parse_constants(self, keyword='constants', prefix='const'):
        """parse constants section"""
        if keyword in self.cfg:
            constants = self.cfg[keyword]
            for name in constants:
                value = constants[name]
                is_model_value = False
                is_symmetrical = False
                if self.model_sym_pat.match(value):
                    is_model_value = True
                    is_symmetrical = True
                    value = self.model_sym_pat.match(value).groups()[0].replace(' ', '').split(',')
                elif self.model_pat.match(value):
                    is_model_value = True
                    value = self.model_pat.match(value).groups()[0].replace(' ', '').split(',')
                elif value == '[model value]':
                    is_model_value = True
                    value = name
                if is_model_value:
                    if isinstance(value, list):  # set of model values
                        model_val = '\n'.join('{} = {}'.format(i, i) for i in value)
                        cfg_str = 'CONSTANTS\n{}\nCONSTANT\n{} <- const_{}_{}'.format(model_val, name, name, id(name))
                        model_val = ', '.join(i for i in value)
                        tla_str = 'CONSTANTS\n{}\nconst_{}_{} ==\n{{{}}}'.format(model_val, name, id(name), model_val)
                        if is_symmetrical:  # symmetry set
                            cfg_str = '{}\nSYMMETRY symm_{}_{}'.format(cfg_str, name, id(value))
                            tla_str = '{}\nsymm_{}_{} ==\nPermutations(const_{}_{})'.format(tla_str, name, id(value),
                                                                                            name, id(name))
                    else:  # model value
                        cfg_str = 'CONSTANT {} = {}'.format(name, value)
                        tla_str = None
                else:  # ordinary assignment
                    cfg_str = 'CONSTANT\n{} <- {}_{}_{}'.format(name, prefix, name, id(name))
                    tla_str = '{}_{}_{} == \n{}'.format(prefix, name, id(name), value)
                self.output_cfg.append(cfg_str)
                self.output_tla.append(tla_str)

    def _parse_override(self):
        """parse override section"""
        self._parse_constants(keyword='override', prefix='over')

    def _parse_const_expr(self):
        """parse const expr section"""
        if 'const expr' in self.cfg:
            const_expr = self.cfg.get('const expr', 'expr', fallback=None)
            if const_expr:
                self.output_cfg.append(None)
                val = 'const_expr_{}'.format(id(const_expr))
                self.output_tla.append('{} ==\n{}\nASSUME PrintT(<<"$!@$!@$!@$!@$!",{}>>)'.format(val, const_expr, val))

    def parse(self):
        self.output_cfg = []
        self.output_tla = []
        self._parse_behavior()
        self._parse_invariants()
        self._parse_properties()
        self._parse_constants()
        self._parse_override()
        self._parse_const_expr()

    def write(self, output_cfg_fn=None, output_tla_fn=None):
        """write parsed buf to file"""
        if output_cfg_fn is None:
            output_cfg_fn = self.output_cfg_fn
        if output_tla_fn is None:
            output_tla_fn = self.output_tla_fn
        with open(output_cfg_fn, 'w') as cfg_f:
            cfg_f.write('{} on {}\n'.format(self.tag, datetime.datetime.now()))
            cfg_f.write('\n\n'.join(filter(None, self.output_cfg)))
            cfg_f.write('\n')
        with open(output_tla_fn, 'w') as tla_f:
            module = '---- MODULE {} ----\n'.format(output_tla_fn.rstrip('.tla'))
            tla_f.write(module)
            tla_f.write('EXTENDS {}, TLC\n'.format(self.module_name))
            tla_f.write('\n----\n\n'.join(filter(None, self.output_tla)))
            tla_f.write('\n{}\n'.format('=' * len(module)))
            tla_f.write('{} on {}\n'.format(self.tag, datetime.datetime.now()))


class TLCRunner:
    """TLC cmdline options"""
    def __init__(self, cfg, tlc_cfg_fn, tla_fn):
        self.cfg = cfg


config_file = 'config.ini' if len(sys.argv) == 1 else sys.argv[1]
cfg = ConfigParser()
cfg.optionxform = str  # case sensitive
cfg.read(config_file)
gtcf = TLCConfigFile(cfg)
gtcf.write()